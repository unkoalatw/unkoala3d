<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>賽博龐克尾熊 3D - 重裝工業</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Microsoft JhengHei', sans-serif;
        }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #aaaaaa;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 5px rgba(100, 100, 100, 0.5);
            font-size: 12px;
            letter-spacing: 3px;
            font-family: monospace;
            text-transform: uppercase;
        }
        #hud {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: rgba(136, 136, 136, 0.4);
            font-family: monospace;
            font-size: 11px;
            line-height: 1.5;
            pointer-events: none;
            border-left: 2px solid rgba(136, 136, 136, 0.2);
            padding-left: 10px;
        }
    </style>
</head>
<body>
    <div id="info">Solid State Projection /// Gyro Stabilized</div>
    <div id="hud">
        GEOMETRY: SOLID TITANIUM<br>
        CONTAINMENT: ACTIVE<br>
        SCANNING: IN PROGRESS
    </div>
    
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        // --- 全域變數 ---
        let scene, camera, renderer, composer, controls;
        let textGroup;
        let rainSystem;
        let ringsGroup; 
        let debrisGroup; 
        let scannerLight; 
        
        const params = {
            text: "尾熊",
            colorFront: "#cccccc", 
            colorSide: "#444444",  
            layers: 60,
            depth: 1.5,
            bloomStrength: 0.4,
            bloomRadius: 0.4,
            bloomThreshold: 0.3
        };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.03); 

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 16);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8; 
            document.body.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = params.bloomThreshold;
            bloomPass.strength = params.bloomStrength;
            bloomPass.radius = params.bloomRadius;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // --- 燈光設置 ---
            const ambientLight = new THREE.AmbientLight(0x111111);
            scene.add(ambientLight);
            
            // 主光源 (固定)
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(5, 10, 5);
            scene.add(dirLight);

            // 掃描燈 (SpotLight)
            scannerLight = new THREE.SpotLight(0xffffff, 100);
            scannerLight.angle = 0.5;
            scannerLight.penumbra = 0.5;
            scannerLight.decay = 2;
            scannerLight.distance = 50;
            scannerLight.position.set(0, 10, 10);
            scene.add(scannerLight);
            
            scannerLight.target.position.set(0, 0, 0);
            scene.add(scannerLight.target);

            // 補光
            const pLight = new THREE.PointLight(params.colorFront, 0.5, 20);
            pLight.position.set(-5, 0, 10);
            scene.add(pLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.maxPolarAngle = Math.PI / 1.5;
            controls.minPolarAngle = Math.PI / 3;

            createCyberpunkText();
            createGridFloor();
            createDataRain();
            createRings();
            createDebris();

            window.addEventListener('resize', onWindowResize);
        }

        function createTextTexture(text, style) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 1024;
            canvas.width = size;
            canvas.height = size;

            ctx.clearRect(0, 0, size, size);
            const centerX = size / 2;
            const centerY = size / 2;

            ctx.font = "bold 400px 'Microsoft JhengHei', sans-serif";
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            if (style === 'front') {
                // 正面：精緻的發光面板
                ctx.shadowColor = params.colorFront;
                ctx.shadowBlur = 15; 
                ctx.lineWidth = 10;
                ctx.strokeStyle = params.colorFront;
                ctx.strokeText(text, centerX, centerY);
                
                ctx.shadowBlur = 0;
                
                const gradient = ctx.createLinearGradient(0, centerY-200, 0, centerY+200);
                gradient.addColorStop(0, "#ffffff");
                gradient.addColorStop(0.5, "#aaaaaa"); 
                gradient.addColorStop(1, "#666666");   
                ctx.fillStyle = gradient;
                ctx.fillText(text, centerX, centerY);

                ctx.lineWidth = 3;
                ctx.strokeStyle = "#333333";
                ctx.beginPath();
                ctx.moveTo(centerX - 450, centerY);
                ctx.lineTo(centerX + 450, centerY);
                ctx.stroke();

            } else if (style === 'back') {
                // 背面
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.scale(-1, 1);
                ctx.translate(-centerX, -centerY);

                ctx.lineWidth = 40; 
                ctx.strokeStyle = params.colorSide;
                ctx.strokeText(text, centerX, centerY);

                ctx.fillStyle = "#111111"; 
                ctx.fillText(text, centerX, centerY);

                ctx.lineWidth = 5;
                ctx.strokeStyle = "#555555";
                ctx.beginPath();
                ctx.arc(centerX, centerY, 420, 0, Math.PI * 2);
                ctx.setLineDash([20, 40]);
                ctx.stroke();

                ctx.restore();

            } else {
                // 側面
                ctx.lineWidth = 50; 
                ctx.strokeStyle = params.colorSide;
                ctx.strokeText(text, centerX, centerY);
                
                ctx.fillStyle = params.colorSide;
                ctx.fillText(text, centerX, centerY);
                
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                for(let i=0; i<size; i+=8) {
                   if(Math.random() > 0.5) ctx.fillRect(0, i, size, 2);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function createCyberpunkText() {
            textGroup = new THREE.Group();
            
            const planeGeo = new THREE.PlaneGeometry(8, 8);
            const textureFront = createTextTexture(params.text, 'front');
            const textureSide = createTextTexture(params.text, 'side');
            const textureBack = createTextTexture(params.text, 'back');

            const materialFront = new THREE.MeshBasicMaterial({
                map: textureFront,
                transparent: true,
                side: THREE.DoubleSide
            });

            const materialSide = new THREE.MeshBasicMaterial({
                map: textureSide,
                transparent: true,
                opacity: 0.95, 
                side: THREE.DoubleSide,
                alphaTest: 0.1 
            });

            const materialBack = new THREE.MeshBasicMaterial({
                map: textureBack,
                transparent: true,
                side: THREE.DoubleSide
            });

            for (let i = 0; i < params.layers; i++) {
                let mat;
                if (i === params.layers - 1) {
                    mat = materialFront;
                } else if (i === 0) {
                    mat = materialBack;
                } else {
                    mat = materialSide;
                }
                
                const layerMesh = new THREE.Mesh(planeGeo, mat);
                const zPos = i * (params.depth / params.layers);
                layerMesh.position.z = zPos;
                
                textGroup.add(layerMesh);
            }

            const box = new THREE.Box3().setFromObject(textGroup);
            const center = box.getCenter(new THREE.Vector3());
            textGroup.position.sub(center);

            scene.add(textGroup);
        }

        function createGridFloor() {
            const gridHelper = new THREE.GridHelper(60, 60, 0x333333, 0x050505);
            gridHelper.position.y = -3.5;
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.2;
            scene.add(gridHelper);
        }

        function createDataRain() {
            const geometry = new THREE.BufferGeometry();
            const count = 100;
            const positions = new Float32Array(count * 6);
            const speeds = [];

            for (let i = 0; i < count; i++) {
                const x = (Math.random() - 0.5) * 60;
                const y = (Math.random() - 0.5) * 60;
                const z = (Math.random() - 0.5) * 40 - 10;
                const len = Math.random() * 1.0 + 0.5;

                positions[i*6] = x; positions[i*6+1] = y; positions[i*6+2] = z;
                positions[i*6+3] = x; positions[i*6+4] = y - len; positions[i*6+5] = z;
                speeds.push(Math.random() * 0.1 + 0.05);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.LineBasicMaterial({
                color: 0x555555,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending
            });

            rainSystem = new THREE.LineSegments(geometry, material);
            rainSystem.userData = { speeds: speeds };
            scene.add(rainSystem);
        }

        function updateDataRain() {
            if (!rainSystem) return;
            const positions = rainSystem.geometry.attributes.position.array;
            const speeds = rainSystem.userData.speeds;
            for (let i = 0; i < speeds.length; i++) {
                const speed = speeds[i];
                positions[i*6+1] -= speed; positions[i*6+4] -= speed;
                if (positions[i*6+1] < -20) {
                    const resetY = 20;
                    const len = Math.abs(positions[i*6+1] - positions[i*6+4]);
                    positions[i*6+1] = resetY; positions[i*6+4] = resetY - len;
                }
            }
            rainSystem.geometry.attributes.position.needsUpdate = true;
        }

        function createRings() {
            ringsGroup = new THREE.Group();
            
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: 0x444444, 
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0x888888,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending
            });

            // 環 1
            const geo1 = new THREE.TorusGeometry(6, 0.05, 16, 100);
            const ring1 = new THREE.Mesh(geo1, glowMat);
            ringsGroup.add(ring1);

            // 環 2
            const geo2 = new THREE.TorusGeometry(7.5, 0.1, 8, 4); 
            const ring2 = new THREE.Mesh(geo2, ringMat);
            ring2.rotation.x = Math.PI / 2;
            ringsGroup.add(ring2);

            // 環 3
            const geo3 = new THREE.TorusGeometry(8.5, 0.02, 16, 100);
            const ring3 = new THREE.Mesh(geo3, glowMat);
            ring3.rotation.y = Math.PI / 4;
            ringsGroup.add(ring3);

            scene.add(ringsGroup);
        }

        function createDebris() {
            debrisGroup = new THREE.Group();
            const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const material = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.5,
                metalness: 0.8
            });

            for (let i = 0; i < 30; i++) {
                const mesh = new THREE.Mesh(geometry, material);
                
                const radius = 5 + Math.random() * 5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;

                mesh.position.setFromSphericalCoords(radius, phi, theta);
                
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                
                mesh.userData = {
                    rotSpeed: {
                        x: (Math.random() - 0.5) * 0.02,
                        y: (Math.random() - 0.5) * 0.02
                    }
                };

                debrisGroup.add(mesh);
            }
            scene.add(debrisGroup);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            if (textGroup) {
                textGroup.position.y = Math.sin(time * 0.5) * 0.1;
                textGroup.rotation.y = Math.sin(time * 0.2) * 0.1; 
            }

            if (ringsGroup) {
                ringsGroup.children[0].rotation.x = time * 0.2;
                ringsGroup.children[0].rotation.y = time * 0.1;
                
                ringsGroup.children[1].rotation.z = -time * 0.15;
                ringsGroup.children[1].rotation.x = Math.sin(time) * 0.2;

                ringsGroup.children[2].rotation.y = time * 0.05;
                ringsGroup.children[2].rotation.z = time * 0.05;
            }

            if (debrisGroup) {
                debrisGroup.rotation.y = time * 0.05;
                debrisGroup.children.forEach(cube => {
                    cube.rotation.x += cube.userData.rotSpeed.x;
                    cube.rotation.y += cube.userData.rotSpeed.y;
                });
            }

            if (scannerLight) {
                scannerLight.position.x = Math.sin(time * 0.5) * 10;
                scannerLight.position.z = Math.cos(time * 0.3) * 10 + 5;
            }

            updateDataRain();
            controls.update();
            composer.render();
        }
    </script>
</body>
</html>
